package edu.agh.tunev.model.cellular;

import java.util.Vector;

import edu.agh.tunev.interpolation.Interpolator;
import edu.agh.tunev.model.AbstractModel;
import edu.agh.tunev.model.cellular.agent.Person;
import edu.agh.tunev.model.cellular.grid.Board;
import edu.agh.tunev.model.cellular.grid.Cell;
import edu.agh.tunev.statistics.KilledStatistics;
import edu.agh.tunev.statistics.Statistics.AddCallback;
import edu.agh.tunev.world.Physics;
import edu.agh.tunev.world.World;
import edu.agh.tunev.world.World.ProgressCallback;

public final class Model extends AbstractModel<Person> {

	public final static String MODEL_NAME = "w¹sowy automat komórkowy";

	public Model(World world, Interpolator interpolator) {
		super(world, interpolator);
	}

	// przyk³adowa dyskretyzacja œwiata -- czyli rozmiar jednej komórki na
	// planszy -- oczywiœcie w metrach -- do zmiany
	private static final double DX = 0.5;
	private static final double DY = 0.4;

	// przyk³adowa dyskretyzacja czasu -- czyli co ile czasu nasze osobniki
	// podejmuj¹ decyzjê o skoku? inaczej: co ile rzeczywistego czasu
	// update'ujemy stan naszego automatu -- oczywiœcie w sekundach -- do zmiany
	private static final double DT = 0.5;

	private Board board;

	@Override
	public void simulate(double duration, Vector<Person> people,
			ProgressCallback progressCallback, AddCallback addCallback) {
		// jakie s¹ rzeczywiste wymiary œwiata?
		double dimX = world.getXDimension();
		double dimY = world.getYDimension();

		// jakie s¹ dyskretne wymiary œwiata? ile komórek w OX i OY?
		// u¿ywa funkcji do t³umaczenia wymiarów z ci¹g³ych na dyskretne z
		// uwzglêdnieniem DX i DY. Zobacz poni¿ej ich definicje.
		int numX = c2dX(dimX) + 1;
		int numY = c2dY(dimY) + 1;

		// stwórz automat (planszê komórek) o obliczonych dyskretnych wymiarach;
		board = new Board(numX, numY);

		// pozaznaczaj osoby na naszej modelowej, wewnêtrznej, planszy
		for (Person p : people) {
			// w której komórce jest ta osoba?
			int ix = c2dX(p.getX());
			int iy = c2dY(p.getY());

			// przesuñ j¹ dok³adnie na œrodek tej komórki...
			p.setPosition(d2cX(ix), d2cY(iy));
			// ... i zrób jej tam "zdjêcie" dla interpolatora w chwili t=0[s]
			interpolator.saveState(p, 0.0);

			// zaznacz w odpowiedniej komórce automatu, ¿e któr¹ osobê
			Cell c = board.get(ix, iy);
			c.setPerson(p);
		}

		// TODO: pododawaj jakieœ wykresy do UI zwi¹zane z tym modelem
		//
		// sidenote: zobacz helpa do interfejsu Statistics: gdy dany wykres
		// pasuje do wielu modeli (np. liczba zabitych jako f(t)), to dodaj jego
		// klasê do pakietu tunev.statistics; jeœli pasuje tylko do tego modelu,
		// to dodaj do pakietu tego modelu
		KilledStatistics killedStatistics = new KilledStatistics();
		addCallback.add(killedStatistics);

		// TODO: pozaznaczaj przeszkody na planszy

		// TODO: pozaznaczaj wyjœcia na planszy

		// kolejne iteracje automatu -- uwaga, ¿adnego czekania w stylu
		// Thread.sleep() -- to ma siê policzyæ *jak najszybciej*! --
		// wyœwietlanie "filmu" z symulacji jest niezale¿ne od obliczania (no,
		// tyle tylko zale¿ne, ¿e mo¿emy wyœwietlaæ tylko do momentu, który ju¿
		// siê policzy³)
		int num = (int) Math.round(Math.ceil(world.getDuration() / DT));
		double t = 0;
		for (int i = 1; i <= num; i++) {
			// uaktualnij rzeczywisty czas naszej symulacji
			t += DT;

			// poœci¹gaj aktualn¹ fizykê do komórek
			for (int ix = 0; ix < numX; ix++)
				for (int iy = 0; iy < numY; iy++) {
					Physics physics = world.getPhysicsAt(t, d2cX(ix), d2cY(iy));
					board.get(ix, iy).setPhysics(physics);
				}

			// przejdŸ do nastêpnego stanu automatu
			board.update();

			// porób zdjêcia osobom w aktualnym rzeczywistym czasie
			for (Person p : people)
				interpolator.saveState(p, t);

			// TODO: uaktualnij wykresy, które mog¹ byæ aktualizowane w trakcie
			// iteracji
			int currentNumDead = 123; // prawdopodobnie ta dana ustawiana
										// gdzie indziej ;p~
			killedStatistics.add(t, currentNumDead);

			// grzecznoœæ: zwiêksz ProgressBar w UI
			progressCallback.update(i, num, (i < num ? "Wci¹¿ liczê..."
					: "Gotowe!"));
		}

		// TODO: ew. wype³nij wykresy, które mog¹ byæ wype³nione dopiero po
		// zakoñczeniu symulacji

		// i tyle ^_^
	}

	/**
	 * Discreet to continuous dimensions for OX.
	 */
	private static double d2cX(int ix) {
		// zwróæ pozycjê w œrodku komórki
		return (0.5 + ix) * DX;
	}

	/**
	 * Discrete to continuous dimensions for OY.
	 */
	private static double d2cY(int iy) {
		// zwróæ pozycjê w œrodku komórki
		return (0.5 + iy) * DY;
	}

	/**
	 * Continuous to discrete dimensions for OX.
	 */
	private static int c2dX(double x) {
		return (int) Math.round(Math.floor(x / DX));
	}

	/**
	 * Continuous to discrete dimensions for OY.
	 */
	private static int c2dY(double y) {
		return (int) Math.round(Math.floor(y / DY));
	}

}
